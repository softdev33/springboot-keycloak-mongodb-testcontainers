# `springboot-testing-mongodb-keycloak`

The goals of this project are:

- Create a REST API application that manages books, `book-service`. The data is stored in
[`MongoDB`](https://www.mongodb.com). The application will have its sensitive endpoints (add/update/delete book) secured.
- Use [`Keycloak`](https://www.keycloak.org) as authentication and authorization server;
- Explore the utilities and annotations that Spring Boot provides when testing applications.

# Build Docker Image

In a terminal and inside `springboot-testing-mongodb-keycloak` root folder, run the following `./gradlew` command to
build `book-service` docker image
```
./gradlew clean build docker -x test -x integrationTest
```
| Environment Variable | Description |
| -------------------- | ------------- |
| `MONGODB_HOST` | Specify host of the `Mongo` database to use (default `localhost`) |
| `MONGODB_PORT` | Specify port of the `Mongo` database to use (default `27017`) |
| `KEYCLOAK_HOST` | Specify host of the `Keycloak` Identity and Access Management solution to use (default `localhost`) |
| `KEYCLOAK_PORT` | Specify port of the `Keycloak` Identity and Access Management solution to use (default `8080`) |

# Start Environment

1. Open one terminal

2. Inside `/springboot-testing-mongodb-keycloak` root folder run
```
docker-compose up -d
```
> To stop and remove containers, networks and volumes, run
> ```
> docker-compose down -v
> ```

3. Wait a little bit until all containers are `Up (healthy)`. You can check their status running
```
docker-compose ps
```

# Configure Keycloak

There are two options to configure `Keycloak`: running `init-keycloak.sh` script or manually using `Keycloak UI`.

## Automatically running script

1. Inside `/springboot-testing-mongodb-keycloak` root folder, un the following script to initialize `Keycloak`.
```
./init-keycloak.sh
```
> This script will create automatically the `company-services` realm, `book-service` client, `manage_books` client
role and the user `ivan.franchin` with the role `manage_books` assigned.

2. `BOOKSERVICE_CLIENT_SECRET` value is shown in the end of the script outputs. It will be needed whenever we call
`Keycloak` to get token for `book-service` application.

## Manually using Keycloak UI

![keycloak](images/keycloak.png)

1. Access the link http://localhost:8080/auth/admin/master/console

2. Login with the credentials
```
Username: admin
Password: admin
```

3. Create a new Realm
- Go to top-left corner and hover the mouse over `Master` realm. A blue button `Add realm` will appear. Click on it.
- On `Name` field, write `company-services`. Click on `Create`.

4. Create a new Client
- Click on `Clients` menu on the left.
- Click `Create` button.
- On `Client ID` field type `book-service`.
- Click on `Save`.
- On `Settings` tab, set the `Access Type` to `confidential`.
- Still on `Settings` tab, set the `Valid Redirect URIs` to `http://localhost:8080/*`.
- Click on `Save`.
- Go to `Credentials` tab. Copy the value on `Secret` field. It will be used on the next steps.
- Go to `Roles` tab.
- Click `Add Role` button.
- On `Role Name` type `manage_books`.
- Click on `Save`.

5. Create a new User
- Click on `Users` menu on the left.
- Click on `Add User` button.
- On `Username` field set `ivan.franchin`.
- Click on `Save`.
- Go to `Credentials` tab.
- Set to `New Password` and `Password Confirmation` the value `123`.
- Turn off the `Temporary` field.
- Click on `Reset password`.
- Confirm the pop up clicking on `Change Password`.
- Go to `Role Mappings` tab.
- Select `book-service` on the combo-box `Client Roles`.
- Add the role `manage_books` to `ivan.franchin`.

**Done!** That is all the configuration needed on `Keycloak`. 

# Getting Access Token

1. In a terminal, export to an environment variable, the `Secret` generated by `Keycloak` to `book-service`.
See **Configure Keycloak** section
```
export BOOKSERVICE_CLIENT_SECRET=...
```

2. Run the script below to get an access token for `ivan.franchin` user
```
BEARER_MY_ACCESS_TOKEN=$(./get-access-token.sh $BOOKSERVICE_CLIENT_SECRET)
```

3. Check the access token returned
```
echo $BEARER_MY_ACCESS_TOKEN
```

4. The access token has a default expiration time of `5 minutes`

# Test using cURL

1. In terminal, call the endpoint `GET /api/books`
```
curl -i http://localhost:9080/api/books
```

It will return:
```
HTTP/1.1 200
[]
```

2. Try to call the endpoint `POST /api/books`, without access token
``` 
curl -i -X POST http://localhost:9080/api/books \
  -H "Content-Type: application/json" \
  -d '{ "authorName": "ivan", "title": "java 8", "price": 10.5 }'
```
It will return:
```
HTTP/1.1 302
```

3. If you do not have the access token stored in `BEARER_MY_ACCESS_TOKEN` environment variable, get it following the
steps describe at **Getting Access Token** section.

4. Call the endpoint `POST /api/books`, now informing the access token
```
curl -i -X POST http://localhost:9080/api/books \
  -H "Authorization: $BEARER_MY_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{ "authorName": "ivan", "title": "java 8", "price": 10.5 }'
```

It will return something like
```
HTTP/1.1 201
{
  "id":"01d984be-26bc-49f5-a201-602293d62b82",
  "authorName":"ivan",
  "title":"java 8",
  "price":10.5
}
```

# Test using Swagger

![swagger](images/swagger.png)

1. Access the link http://localhost:9080/swagger-ui.html

2. Click on `GET /api/books` to open it. Then, click on `Try it out` button and, finally, click on `Execute` button.
It will return a http status code `200` and an empty list or a list with some books if you've already added them.

3. Now, let's try a secured endpoint without authentication. Click on `POST /api/books` to open it. Then, click on
`Try it out` button (you can use the default values) and, finally, on `Execute` button.
It will return:
```
TypeError: Failed to fetch
```

4. Get the access token as explained at **Getting Access Token** section.

5. Copy the token generated (something like that starts with `Bearer ...`) and go back to `Swagger`.

6. Click on the `Authorize` button and paste access token (copied previously) in the value field. Then, click on
`Authorize` and, to finalize, click on `Close`.

7. Go to `POST /api/books`, click on `Try it out` and then on `Execute` button
It will return something like
```
HTTP/1.1 201
{
  "id": "5cf212c3-7902-4141-968b-82ae7a3443f1",
  "authorName": "Craig Walls",
  "title": "Spring Boot",
  "price": 10.5
}
```

## Running book-service with Gradle

During development, it is easy to just run the application instead of always build the docker image before running
it. In order to do that, comment `book-service` in `docker-compose.yml` file (so that it does not start when you start
the environment) and run it with Gradle.

1. Open a terminal

2. In `springboot-testing-mongodb-keycloak` root folder, start `book-service` by running
```
./gradlew clean bootRun -Dserver.port=9080
```

3. Export to `BOOKSERVICE_CLIENT_SECRET`, the `Client Secret` generated by `Keycloak`.

4. In order to get the access token from `Keycloak`, run the following command. Note that we are informing `localhost`
in the second argument. It changes `Keycloak` host inside the script.
```
BEARER_MY_ACCESS_TOKEN=$(./get-access-token.sh $BOOKSERVICE_CLIENT_SECRET localhost)
echo $BEARER_MY_ACCESS_TOKEN
```

5. Test using cURL or Swagger are the same as explained above.

# Useful Links

### jwt.io

With [jwt.io](https://jwt.io) you can inform the JWT token received from `Keycloak` and the online tool decodes the
token, showing its header and payload.

## Running unit and integration testing

1. In order to run unit and integration testing type
```
./gradlew test integrationTest
```

2. From `springboot-testing-mongodb-keycloak` root folder, unit testing report can be found in
```
/build/reports/tests/test/index.html
```

3. From `springboot-testing-mongodb-keycloak` root folder, integration testing report can be found in
```
/build/reports/tests/integrationTest/index.html
```

# More about testing Spring Boot Applications

Spring Boot provides a number of utilities and annotations to help when testing your application.

## Unit Testing

The idea of the unit testing is to test each layer of the application (repository, service and controller) individually.
The repository classes usually don't depends on any other classes, so we can write test cases without any mocking.
On the other hand, the services classes depend on repositories. So, as we have already test cases to cover the repositories, while writing test cases for the services we don't need to care about the quality of the repositories classes. So, every calls to repositories classes should be mocked.
The same happens to controller classes that depends on the services classes. While writing tests for the controllers, service calls on the controller classes should be mocked.

### Repository Testing

You can use `@DataMongoTest` to test `MongoDB` applications.
By default, it configures an in-memory embedded `MongoDB` (if available), configures a `MongoTemplate`, scans for `@Document` classes, and configures Spring Data `MongoDB` repositories.
The embedded `MongoDB` added in the `build.gradle` and can by found in the link: https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo
Regular `@Component` beans are not loaded into the `ApplicationContext`.
An example of utilization is:

```
@ExtendWith(SpringExtension.class)
@DataMongoTest
public class BookRepositoryTests {

    @Autowired
    private MongoTemplate mongoTemplate;

	@Autowired
	private BookRepository bookRepository;

	// Tests ..
}
```

### Service Testing

In order to test the application services, we can use a something similar as shown below, as we create an instance of `BookServiceImpl` and mock the `bookRepository` 

```
@ExtendWith(SpringExtension.class)
public class BookServiceImplTest {

    private BookService bookService;
    private BookRepository bookRepository;

    @Before
    public void setUp() {
        bookRepository = mock(BookRepository.class);
        bookService = new BookServiceImpl(bookRepository);
    }
    
    // Tests
}
```

### Controller Testing

`@WebMvcTest` annotation can be used to test whether Spring MVC controllers are working as expected.
`@WebMvcTest` is limited to a single controller and is used in combination with `@MockBean` to provide mock implementations for required dependencies.
`@WebMvcTest` also auto-configures `MockMvc`. Mock MVC offers a powerful way to quickly test MVC controllers without needing to start a full HTTP server.
In the example below, you can see that we mocking the services (in this case `bookService`) used by `BookController`.
The annotation `@AutoConfigureMockMvc(secure = false)` is used to disable security configuration. 

```
@ExtendWith(SpringExtension.class)
@WebMvcTest(BookController.class)
@AutoConfigureMockMvc(secure = false)
public class BookControllerTests {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private BookService bookService;
    
    // Tests ... 
}
```

### DTO Testing

`@JsonTest` annotation can be used to test whether object JSON serialization and deserialization is working as expected.
In the example below, it is used `JacksonTester`. However, `GsonTester`, `JsonbTester` and `BasicJsonTester` could also be used instead.
Btw, I've tried to use all of them, but just `JacksonTester` worked easily and as expected.  

```
@ExtendWith(SpringExtension.class)
@JsonTest
public class MyJsonTests {

	@Autowired
	private JacksonTester<VehicleDetails> json;

	// Tests ...
}
```

## Integration Testing

The main goal of the integration tests is, as its name suggests, to integrate the different layers of the application. Here, no mocking is involved and a full running HTTP server is needed. 
So, in order to have it, we can use the `@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)` annotation. What this annotation does is to start a full running server running in a random ports. Spring Boot also provides a `TestRestTemplate` facility, for example:

```
@ExtendWith(SpringExtension.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
public class RandomPortTestRestTemplateExampleTests {

	@Autowired
	private TestRestTemplate restTemplate;

	// Tests ...

}
```

Integration tests should run separated from the unit tests and, mainly, it should runs after unit tests. In this project, we created a new integrationTest Gradle task to handle exclusively integration tests.

# References

- https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html
- http://www.baeldung.com/spring-boot-testing

# Issues

Unable to update `spring-boot` version to `2.1.4`. There is a work around (https://stackoverflow.com/questions/53318134/unable-to-use-keycloak-in-spring-boot-2-1-due-to-duplicated-bean-registration-ht).
However, I will wait for the fix.

```
2019-04-16 10:06:45.329  WARN 2850 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name 'httpSessionManager' defined in class path resource [com/mycompany/bookservice/config/KeycloakSecurityConfig.class]: Cannot register bean definition [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=keycloakSecurityConfig; factoryMethodName=httpSessionManager; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/mycompany/bookservice/config/KeycloakSecurityConfig.class]] for bean 'httpSessionManager': There is already [Generic bean: class [org.keycloak.adapters.springsecurity.management.HttpSessionManager]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in URL [jar:file:/Users/ivanfranchin/.gradle/caches/modules-2/files-2.1/org.keycloak/keycloak-spring-security-adapter/5.0.0/7c427d57886c0d29864ab8bced7cb52c4f7685a7/keycloak-spring-security-adapter-5.0.0.jar!/org/keycloak/adapters/springsecurity/management/HttpSessionManager.class]] bound.
2019-04-16 10:06:45.356  INFO 2850 --- [           main] ConditionEvaluationReportLoggingListener : 

Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.
2019-04-16 10:06:45.359 ERROR 2850 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : 

***************************
APPLICATION FAILED TO START
***************************

Description:

The bean 'httpSessionManager', defined in class path resource [com/mycompany/bookservice/config/KeycloakSecurityConfig.class], could not be registered. A bean with that name has already been defined in URL [jar:file:/Users/ivanfranchin/.gradle/caches/modules-2/files-2.1/org.keycloak/keycloak-spring-security-adapter/5.0.0/7c427d57886c0d29864ab8bced7cb52c4f7685a7/keycloak-spring-security-adapter-5.0.0.jar!/org/keycloak/adapters/springsecurity/management/HttpSessionManager.class] and overriding is disabled.

Action:

Consider renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding=true
```